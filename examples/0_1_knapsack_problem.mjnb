{"fileName":"0_1_knapsack_problem.mjnb","cells":[{"cellType":"MARKDOWN","id":"1e4143e84d694ae79d302de141dc604d","cellContent":"# 0 1 Knapsack Problem Solution\nClick the link icon at the top right to view problem prompt"},{"cellType":"MARKDOWN","id":"7a8a1ac775c345068093a1a80904ca8a","cellContent":"### Recursive solution (naive)\nIn this top down solution we consider all subsets of items in a binary fashion (either including it or not), and\ncalculate the weight of each subset while picking the maximum. We stop once we either exhaust through all of the\nitems or when the weight limit is exceeded."},{"cellType":"CODE","id":"b1993f8767d64560a76b6059695b1115","cellContent":"int knapSackRecursive(int W, int[] wt, int[] val, int n) {\n  if (n == 0 || W == 0) {\n    return 0;\n  }\n  \n  if (wt[n-1] > W) {\n    return knapSackRecursive(W, wt, val, n-1);\n  }\n  \n  return Math.max(knapSackRecursive(W-wt[n-1], wt, val, n-1) + val[n-1],\n                  knapSackRecursive(W, wt, val, n-1));\n}"},{"cellType":"MARKDOWN","id":"e69c359b957d4cbd8214cd0b0837f5f6","cellContent":"#### Analysis\n* Time complexity: O(2^n) where n is the number of items\n* Space complexity: O(n) where n is the number of items"},{"cellType":"MARKDOWN","id":"095480d29df14669a3f4d6c5fef35236","cellContent":"### Dynamic programming solution\nIn order to avoid recomputing subproblems, we define a matrix K and construct it in a bottom up manner."},{"cellType":"CODE","id":"f023fa7a545a42acadf86efe0a987091","cellContent":"int knapSackDP(int W, int[] wt, int[] val, int n) {\n  int[][] K = new int[n+1][W+1];\n  \n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= W; j++) {\n      if (i == 0 || j == 0) {\n        K[i][j] = 0;\n      } else if (wt[i-1] <= j) {\n        K[i][j] = Math.max(K[i-1][j-wt[i-1]] + val[i-1], K[i-1][j]);\n      } else {\n        K[i][j] = K[i-1][j];\n      }\n    }\n  }\n  \n  return K[n][W];\n}"},{"cellType":"MARKDOWN","id":"dc26796778514f74a940318c3df368f9","cellContent":"#### Analysis\n* Time complexity: O(n*m) where n is the number of items and m is the capacity of the knapsack\n* Space complexity: O(n*m) where n is the number of items and m is the capacity of the knapsack"},{"cellType":"CODE","id":"6c5983e30c694da984d120912b0eb635","cellContent":"int knapSack(int W, int[] wt, int[] val, int n) {\n  \/\/ return knapSackRecursive(W, wt, val, n);\n  return knapSackDP(W, wt, val, n);\n}"},{"cellType":"MARKDOWN","id":"0a8488d4a1684a76a0fdfc8498c0d061","cellContent":"##### Example input\n```\n50\n[10, 20, 30]\n[60, 100, 120]\n3\n```\n##### Example output\n```\n220\n```"}],"problemSourceURL":"http:\/\/www.geeksforgeeks.org\/knapsack-problem\/","displayName":"0 1 Knapsack Problem","mainFunctionSignature":"knapSack","timeCreated":1512158598955,"lastModified":1512158598955,"returnType":"int","tags":["dynamic programming","geeksforgeeks"]}